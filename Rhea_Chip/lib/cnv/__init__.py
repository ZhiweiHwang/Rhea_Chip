#! /usr/bin/env python
# -*- coding: utf-8 -*-
# 代码有问题别找我！虽然是我写的，并且我觉得它是没问题的，如果不是你的操作原因，或许是它自己长歪了！
import cPickle
import re
from itertools import chain, groupby
from operator import itemgetter
from smart_open import smart_open

__title__ = '__init__.py'
__version__ = 'v1.0'
__author__ = 'huang'
__mtime__ = '14:27 02/22 2016'
__url__ = 'https://github.com/ZhiweiHwang/Rhea_Chip'
__description__ = 'A Simple pipeline use for the CNV analysis of human data generated by NGS approaches.'
__note__ = "Please specify environment variable Rhea_Chip_Home as the home of Rhea_Chip pipeline."

flatten = chain.from_iterable
LEFT, RIGHT = 1, -1


class CNVdata(object):
	pass


def join_ranges(data, offset=0):
	data = sorted(flatten(((start, LEFT), (stop + offset, RIGHT)) for start, stop in data))
	c = 0
	x = int()
	for value, label in data:
		if c == 0:
			x = value
		c += label
		if c == 0:
			yield x, value - offset


def join_numbers(numberlist):
	for k, g in groupby(enumerate(sorted(numberlist)), lambda (i, x): i - x):
		group = map(itemgetter(1), g)
		if len(group) > 1:
			yield [group[0], group[-1]]
		else:
			yield [group[0], group[0]]


def _chrom_valued(chrom):
	c = chrom.replace("chr", "")
	try:
		n_v = int(c)
	except ValueError:
		n_v = sum([ord(i) for i in list(c)])
	return n_v


def initialCN(dep, ploid=2):
	copys = list()
	if not len(dep):
		return copys
	mdep = sum([float(i) for i in dep]) / float(len(dep))
	mdep *= 2.0 / float(ploid)
	for i in dep:
		dr = float(i) / mdep
		if dr < 0.1:
			copys.append(0)
		elif dr < 0.7:
			copys.append(1)
		elif dr <= 1.35:
			copys.append(2)
		elif dr <= 1.75:
			copys.append(3)
		elif dr <= 2.25:
			copys.append(4)
		else:
			copys.append(5)
	return copys


class SaveLoad(object):
	"""
    Objects which inherit from this class have save/load functions, which un/pickle
    them to disk.

    This uses pickle for de/serializing, so objects must not contain
    unpicklable attributes, such as lambda functions etc.

    """

	def __init__(self, fname):
		self.fname = fname

	def load(self):
		with smart_open(self.fname) as f:
			return cPickle.loads(f.read())

	def save(self, d, pickle_protocol=2):
		handle = smart_open(self.fname, 'w')
		cPickle.dump(d, handle, protocol=pickle_protocol)
		handle.close()


def count_gc(bases):
	if not len(bases):
		return 0.0
	try:
		gc_base = len(re.findall("[GC]", bases))
		total_base = len(re.findall("[GCTA]", bases))
		return round(float(gc_base) / total_base, 4)
	except ZeroDivisionError:
		return 0.4
