#! /usr/bin/env python
# -*- coding: utf-8 -*-
# The MIT License (MIT)
# Copyright (c) 2015 Joey Hwong
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions: The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
# LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
###############################################################################

Rhea_Chip.py
A Simple pipeline for the analysis of human data generated by NGS approaches.
Author: Joey Hwong (joeyhwong@hotmail.com)
Version: 1.1
usage: Rhea_Chip.py [-h] [--version] --samplelist [samplelist] --config [config.json] [options]
Expected arguments:
  -s, --samplelist     [FILE]  the sample list file
                       Column 1:        sample name
                       Column 2:        family name
                       Column 3:        FQ file [formact: lane1/fq1:lane1/adapter1;lane1/fq2:lane1/adapter2|
                                            lane2/fq1:lane2/adapter1;lane2/fq2:lane2/adapter2]
                       Column 4:        case/control
  -c, --config         [FILE]  the config file, contain all specific settings in a json file
Optional arguments:
  -h, --help           show this help message and exit
  --version        show program's version number and exit
  -m, --mode  [STR]    Fam for family analysis, Single for single analysis
  -o, --out   [STR]    the output dir

###############################################################################
"""
from optparse import OptionParser, OptionGroup
import sys
import re
import os
import logging
import json
import tempfile
import shutil
from collections import defaultdict
from copy import copy
import time
import gzip

temppath = tempfile.mkdtemp()
logger = logging.getLogger(__name__)
logging.basicConfig(format='%(asctime)s: %(levelname)s: %(message)s', filename=os.path.join(temppath, 'Rhea_chip.log'),
                    level=logging.INFO)
logger.info('Running: python %s' % ' '.join(sys.argv))
temptime = time.strftime('%Y.%m.%d', time.localtime(time.time()))


class CreateFolder(object):
	"""
	a simple class use for makedir
	"""

	def __init__(self, rootdir):
		self.rootdir = self.folder_confirm(os.path.realpath(rootdir))

	@staticmethod
	def folder_confirm(realdir):
		drive = realdir.split(os.sep)
		temp_dir = '/'
		while drive:
			temp_dir = os.path.join(temp_dir, drive.pop(0))
			try:
				os.makedirs(temp_dir)
			except OSError:
				if os.path.isdir(temp_dir):
					pass
				else:
					raise

		return realdir

	def create_subdirectory(self, sublist):
		for dirpath in sublist:
			if not len(dirpath):
				continue
			newpath = os.path.join(self.rootdir, dirpath)
			try:
				if os.path.isfile(newpath):
					os.rename(newpath, str(newpath) + temptime)
				os.makedirs(newpath)
			except OSError:
				if os.path.isdir(newpath):
					pass
				else:
					raise
		return True


class ConfigPhrase(object):
	def __init__(self, filein, fileout=None):
		"""
		Phrase config file
		"""
		self.Rheadir = os.getcwd()
		self.raw_config_file = filein
		self.config_save_file = fileout
		self.config = self.config_load
		self.tools = defaultdict(dict)
		self.tools["config_save_file"]["PATH"] = self.config_save_file
		self.config_stat = self.check_config

	@property
	def config_load(self):
		"""
		loadding all the personalized settings from json file and return a dict
		and store all personalized settings to a file in json format
		"""
		with open(self.raw_config_file) as config_file:
			config = json.load(config_file)
		if self.config_save_file is not None:
			with open(self.config_save_file, 'w') as f:
				json.dump(config, f, indent=4)
		try:
			self.Rheadir = config['Rhea_Chip_dir']['PATH']
		except ValueError:
			pass
		return config

	def get_real_path(self, indexpath):
		realpath = os.path.realpath(os.path.join(self.Rheadir, indexpath))
		return os.path.exists(realpath), realpath

	@property
	def check_config(self):
		"""
		Check that all required parameters are complete
		"""
		try:
			root_check = os.path.exists(self.Rheadir)
			for software in ('SOAPnuke', 'picard', 'samtools', 'JAVA', 'python'):
				temp_check, realpath = self.get_real_path(self.config['Tools'][software]['PATH'])
				root_check *= temp_check
				self.tools[software]['PATH'] = realpath
				if 'Parameters' in self.config['Tools'][software]:
					self.tools[software]['Parameters'] = self.config['Tools'][software]['Parameters']
				else:
					self.tools[software]['Parameters'] = str

			for software in ('BWA', 'GATK3'):
				temp_check, realpath = self.get_real_path(self.config['Tools'][software]['PATH'])
				root_check *= temp_check
				self.tools[software]['PATH'] = realpath
				self.tools[software]['Parameters'] = defaultdict(str)
				if "Parameters" in self.config['Tools'][software]:
					for m, p in self.config['Tools'][software]['Parameters'].iteritems():
						if len(p):
							self.tools[software]['Parameters'][m] = p

			for gender in ('male', 'female'):
				temp_check, realpath = self.get_real_path(self.config['Datasets']['Reference'][gender] + '.fai')
				root_check *= temp_check
				temp_check, realpath = self.get_real_path(self.config['Datasets']['Reference'][gender])
				root_check *= temp_check
				self.tools['Reference'][gender] = realpath

			for otherdata in ('dbsnp', 'Refseq'):
				temp_check, realpath = self.get_real_path(self.config['Datasets'][otherdata]['PATH'])
				root_check *= temp_check
				self.tools[otherdata]['PATH'] = realpath

			for need_program in ('bam2gender', 'depthqc', 'vcf_phasing'):
				temp_check, realpath = self.get_real_path(self.config['Programs'][need_program]['PATH'])
				root_check *= temp_check
				self.tools[need_program]['PATH'] = realpath

		except ValueError:
			root_check = 0

		try:
			lbp = self.config['Tools']['LD_LIBRARY_PATH']['PATH']
			self.tools['LD_LIBRARY_PATH']['PATH'] = lbp + r':$LD_LIBRARY_PATH'
		except ValueError:
			self.tools['LD_LIBRARY_PATH']['PATH'] = r'$LD_LIBRARY_PATH'

		try:
			bedfile = self.config["Personal Analysing"]["Bed"]["Target bed"]
			temp_check_target, self.tools["Bed"]["Target bed"] = self.get_real_path(bedfile)
		except ValueError:
			self.tools["Bed"]["Target bed"] = ""
		try:
			bedfile = self.config["Personal Analysing"]["Bed"]["Flank bed"]
			temp_check_flank, self.tools["Bed"]["Flank bed"] = self.get_real_path(bedfile)
		except ValueError:
			self.tools["Bed"]["Flank bed"] = self.tools["Bed"]["Target bed"]
		try:
			if not self.tools["Bed"]["Flank bed"]:
				self.tools["Bed"]["Target bed"] = self.bed_region_take()
				self.tools["Bed"]["Flank bed"] = self.tools["Bed"]["Target bed"]
			elif not self.tools["Bed"]["Target bed"]:
				self.tools["Bed"]["Target bed"] = self.tools["Bed"]["Flank bed"]
			self.tools["Bed"]["Target bed"] = self.check_contig_from_reference(self.tools["Bed"]["Target bed"])
			self.tools["Bed"]["Flank bed"] = self.check_contig_from_reference(self.tools["Bed"]["Flank bed"])
		except Exception:
			root_check = 0
		return root_check

	def bed_region_take(self):
		tranlist = set()
		genelist = set()
		try:
			temp_check, realpath = self.get_real_path(self.config["Personal Analysing"]["Trans List"]['PATH'])
			if temp_check:
				with open(realpath) as trans:
					for t in trans:
						t = re.sub('\.[^\.]+$', '', t.strip())
						tranlist.add(t)
		except Exception:
			pass
		try:
			temp_check, realpath = self.get_real_path(self.config["Personal Analysing"]["Gene List"]['PATH'])
			if temp_check:
				with open(realpath) as genes:
					for g in genes:
						genelist.add(g.strip())
		except Exception:
			pass
		target_bed = open(os.path.join(temppath, "target.bed"), 'w')
		_refbed = self.tools['Refseq']['PATH']
		refbed = gzip.open(_refbed) if _refbed.endswith(".gz") else open(_refbed)
		for lines in refbed:
			rows = lines.strip().split('\t')
			if len(rows) < 9:
				continue
			trans = re.sub('\.[^\.]+$', '', rows[0])
			genes = rows[2]
			chrom = rows[3]
			start = rows[4]
			end = rows[5]
			region = rows[8]
			if region.startswith('IVS') or not start.isdigit() or not end.isdigit() or not chrom.startswith("chr"):
				continue
			if len(tranlist) and trans not in tranlist:
				continue
			if len(genelist) and genes not in genelist:
				continue
			target_bed.write("\t".join([chrom, start, end]) + '\n')
		target_bed.close()
		refbed.close()
		return target_bed

	def check_contig_from_reference(self, bedfile):
		refer = dict()
		with open(self.tools['Reference']['male'] + '.fai') as ref:
			for line in ref:
				rows = line.strip().split('\t')
				refer[rows[0]] = int(rows[1])
		newregion = open(os.path.join(temppath, "TEMP." + os.path.basename(bedfile)), 'w')
		with open(bedfile) as regions:
			for line in regions:
				rows = line.strip().split('\t')
				if rows[0] not in refer or int(rows[2]) > refer[rows[0]]:
					logger.info("Sorry, Region: %s is excluded from the reference sequence" % line.strip())
					continue
				newregion.write(line)
		newregion.close()
		return os.path.join(temppath, "TEMP." + os.path.basename(bedfile))


class SampleMessagePhrase(object):
	def __init__(self, samplename, family, library, fqline, sampletype):
		self.samplename = samplename
		self.family = family if re.compile('[a-z0-9]', re.I).search(family) else samplename
		self.fastq = dict()
		self.sampletype = sampletype
		self.library = library
		self.fastq['fqtype'] = 'SE'
		lanes = [i for i in fqline.split('|') if len(i)]
		self.fastq['lanes_number'] = len(lanes)
		self.fastq['fqlist'] = defaultdict(dict)
		for lanenum in range(self.fastq['lanes_number']):
			lane_name = 'lane_%s' % str(lanenum + 1)
			fqs = [i for i in lanes[lanenum].split(';') if len(i)]
			if len(fqs) == 2:
				self.fastq['fqtype'] = 'PE'
			elif self.fastq['fqtype'] == 'PE':
				logger.info('Sample %s maybe lost any fastq(s), lane %d ?' % (self.samplename, lanenum))
				raise
			for fqnum in range(len(fqs)):
				fqname = 'fastq_%s' % str(fqnum + 1)
				fastq = fqs[fqnum].split(':')
				if len(fastq) > 1:
					subfastq, subadaptor = fastq[:2]
				else:
					subfastq = fastq[0]
					subadaptor = ''
				if not os.path.isfile(subfastq):
					raise IOError("No such file: %s" % subfastq)
				self.fastq['fqlist'][lane_name][fqname] = {'adapter': subadaptor, 'fastq': subfastq}


def mksymlink(oldpath, linkpath):
	"""
	Establish a soft link for the target file
	"""
	if not len(oldpath) or not os.path.exists(oldpath):
		return
	suffix = re.compile('(\\.[a-z]+)$', re.I).search(oldpath)
	if suffix and not linkpath.endswith(suffix.group()):
		linkpath += suffix.group()
	if os.path.isdir(linkpath):
		shutil.rmtree(linkpath)
	elif os.path.isfile(linkpath):
		os.remove(linkpath)
	os.symlink(oldpath, linkpath)


class SampleMessage(object):
	def __init__(self, filename):
		self.samples = dict()
		self.familys = defaultdict(set)
		f_out = open(os.path.join(temppath, "sample.list"), 'w')
		with open(filename) as samplelist:
			for sampleline in samplelist:
				sample_m = sampleline.strip().split('\t')
				if len(sample_m) < 4:
					logger.info('Something error found in samplelist: %s' % sample_m[0])
				samplename, samplefamily, library, samplefq, sampletype = sample_m[:5]
				if samplename in self.samples:
					logger.info('Found duplicate of sample: %s' % samplename)
					continue
				self.samples[samplename] = SampleMessagePhrase(samplename, samplefamily, library, samplefq, sampletype)
				f_out.write("\t".join([samplename, samplefamily, library, samplefq, sampletype]) + '\n')
				self.familys[self.samples[samplename].family].add(samplename)
		f_out.close()

	def work_path_prepare(self, workpath):
		for w_p in ('alignment', 'doc/QC', 'fq/raw_data', 'fq/clean_data', 'script', 'variation'):
			prepair_dir = CreateFolder(os.path.join(workpath, w_p))
			prepair_dir.create_subdirectory(self.familys.keys())

		for fam, sam in self.familys.iteritems():
			for samplename in sam:
				message = self.samples[samplename]
				for lane in message.fastq['fqlist'].keys():
					for fq in message.fastq['fqlist'][lane].keys():
						adp = message.fastq['fqlist'][lane][fq]['adapter']
						fastq = message.fastq['fqlist'][lane][fq]['fastq']
						mksymlink(adp, os.path.join(workpath, 'fq/raw_data', samplename,
						                            '.'.join([samplename, lane, fq, 'adapter.list'])))
						mksymlink(fastq, os.path.join(workpath, 'fq/raw_data', samplename,
						                              '.'.join([samplename, lane, fq, 'fq'])))


class Pipeline(object):
	"""
	create all scripts for analysis
	"""

	def __init__(self, sample, tools, outdir):
		self._sample = sample
		self.sample = self._sample.samplename
		self.library = self._sample.library
		self.familys = sample.family
		self.scriptpath = os.path.join(outdir, "script", self.familys)
		qcpath = os.path.join(outdir, "doc/QC", self.familys)
		prepair_dir = CreateFolder(qcpath)
		prepair_dir.create_subdirectory([self.sample])
		self.targetbed = os.path.join(outdir, 'doc', temptime + '.Target.phig.norm.bed')
		self.flankbed = os.path.join(outdir, 'doc', temptime + '.Flank.phig.norm.bed')
		self.qcpath = os.path.join(outdir, "doc/QC", self.familys, self.sample)
		self.cleanfq = os.path.join(outdir, "fq/clean_data", self.familys)
		self.alignpath = os.path.join(outdir, "alignment", self.familys)
		self.vcfpath = os.path.join(outdir, "variation", self.familys)
		self.javatmp = os.path.join(outdir, "javatmp")
		self.finalbam = os.path.join(self.alignpath, self.sample + '.final.bam')
		self.finalvcf = os.path.join(self.vcfpath, self.sample + '.final.vcf.gz')
		self.tools = tools
		self.configfile = self.tools["config_save_file"]["PATH"]

	def run(self):
		self.step1_filter_adapter()
		self.step2_bwa_alignment()
		self.step3_merge_bam()
		self.step4_dupmark_bam()
		self.step5_realigner()
		self.step6_1_variation_call()
		self.step6_2_depth_qc()

	def bash_header_and_foot(self, meassagelist, step):
		"""
		Add the header and foot into the script
		"""
		if not len(meassagelist):
			return list()
		commandlist = ['#!/bin/bash\n',
		               'program_start=`date "+%s"`\n',
		               'export LD_LIBRARY_PATH=%s\n' % self.tools['LD_LIBRARY_PATH']['PATH'],
		               '\nprogram_end=`date "+%s"`\n',
		               'run_time=`expr "$program_end" - "$program_start"`\n',
		               'echo - | awk -v S=$run_time \'{printf "%s %s spends %%02d:%%02d:%%02d\\n",'
		               ' S/(60*60),S%%(60*60)/60,S%%60}\'\nexit 0\n' % (self.sample, step)]
		commandlist[3:3] = meassagelist
		return commandlist

	def _stat_command_formact(self, messages, level=1):
		command = ['if [ $? -ne 0 ]; then', '\techo "{0} {1} failed."'.format(self.sample, messages), '\texit 1', 'fi\n']
		levels = "\n" + "\t" * (level - 1)
		return levels.join(command)

	def step1_filter_adapter(self):
		"""
		Step1 filter adapter, QC
		"""
		soapnuke = self.tools["SOAPnuke"]["PATH"]
		parameters = self.tools["SOAPnuke"]["Parameters"]
		commandformat = soapnuke + " filter {0} {1} " + parameters + " -o {2} {3}\n\n"
		for lanes in self._sample.fastq['fqlist'].keys():
			f_out = os.path.join(self.scriptpath, ".".join(["Step1", self.sample, lanes, "filter.sh"]))
			ms = "Step1 %s filter " % lanes
			p2 = os.path.join(self.cleanfq, self.sample + "_" + lanes)
			if os.path.isdir(p2):
				shutil.rmtree(p2)
			elif os.path.isfile(p2):
				os.remove(p2)
			os.makedirs(p2)
			adp = self._sample.fastq['fqlist'][lanes]['fastq_1']['adapter']
			fq = self._sample.fastq['fqlist'][lanes]['fastq_1']['fastq']
			p1 = "-1 %s" % fq
			p0 = "-f %s" % adp if len(adp) else " "
			p3 = "-C %s" % ".".join([self.sample, lanes, "1.fq.gz"])
			if self._sample.fastq['fqtype'] is 'PE':
				adp2 = self._sample.fastq['fqlist'][lanes]['fastq_2']['adapter']
				fq2 = self._sample.fastq['fqlist'][lanes]['fastq_2']['fastq']
				p1 += " -2 %s" % fq2
				p0 += " -r %s" % adp2 if len(adp2) else " "
				p3 += " -D %s" % ".".join([self.sample, lanes, "2.fq.gz"])
			messagelist = [commandformat.format(p0, p1, p2, p3), self._stat_command_formact(ms),
			               "mv %s/*.txt %s\n" % (p2, self.qcpath)]
			messagelist = self.bash_header_and_foot(messagelist, "Step1 %s" % ms)
			with open(f_out, 'w') as fout:
				fout.write("".join(messagelist))

	def _bwa_alignment(self, mode, gender, fqlist, outbam):
		rg = '@RG\\tID:%s\\tSM:%s\\tLB:%s\\tPL:ILLUMINA\\tPU:%s' % (self.familys, self.sample, self.library, self.sample)
		messagelist = list()
		if mode is 'aln':
			commandformat = "{0} aln -f {1} {2} {3} {4}\n"
			p0 = self.tools['BWA']['PATH']
			p2 = self.tools["BWA"]["Parameters"][mode]
			p3 = self.tools['Reference'][gender]
			for fq in fqlist:
				p1 = fq + '.sai'
				p4 = fq
				messagelist.append(commandformat.format(p0, p1, p2, p3, p4))
			commandformat = "{0} samse -r \"{1}\" {2} {3} {4} {5} | {6} view -S -b -o {7} -\n\n"
			p1 = rg
			p2 = self.tools["BWA"]["Parameters"]["samse"]
			p4 = " ".join([i + '.sai' for i in fqlist])
			p5 = " ".join(fqlist)
			p6 = self.tools['samtools']['PATH']
			p7 = outbam
			messagelist.append(commandformat.format(p0, p1, p2, p3, p4, p5, p6, p7))
		else:
			commandformat = "{0} mem -R \"{1}\" {2} {3} {4} | {5} view -S -b -o {6} -\n\n"
			p0 = self.tools['BWA']['PATH']
			p1 = rg
			p2 = self.tools["BWA"]["Parameters"][mode]
			p3 = self.tools['Reference'][gender]
			p4 = " ".join(fqlist)
			p5 = self.tools['samtools']['PATH']
			p6 = outbam
			messagelist.append(commandformat.format(p0, p1, p2, p3, p4, p5, p6))
		return messagelist

	def step2_bwa_alignment(self):
		"""
		Step2 alignment, gender_check
		"""
		if self._sample.fastq['fqtype'] is 'PE' and 'mem' in self.tools["BWA"]["Parameters"]:
			mode = 'mem'
		elif self._sample.fastq['fqtype'] is 'SE' and 'aln' in self.tools["BWA"]["Parameters"]:
			mode = 'aln'
		elif 'mem' in self.tools["BWA"]["Parameters"]:
			mode = "mem"
		else:
			mode = 'aln'
		for lanes in self._sample.fastq['fqlist'].keys():
			clean_fq_path = os.path.join(self.cleanfq, self.sample + "_" + lanes)
			fqn = 3 if self._sample.fastq['fqtype'] is 'PE' else 2
			fqlist = [os.path.join(clean_fq_path, ".".join([self.sample, lanes, str(n), "fq.gz"])) for n in
			          range(1, fqn)]
			outbam = os.path.join(self.alignpath, ".".join([self.sample, lanes, 'raw.bam']))
			messagelist = self._bwa_alignment(mode, 'male', fqlist, outbam)
			ms = "Step2 bwa %s %s " % (mode, lanes)
			messagelist.append(self._stat_command_formact(ms))
			commandformat = "{0} -Djava.io.tmpdir={1} -jar {2}/SortSam.jar INPUT={3} OUTPUT={4} " \
			                "SORT_ORDER=coordinate VALIDATION_STRINGENCY=SILENT\n"
			p0 = self.tools['JAVA']['PATH']
			p1 = self.javatmp
			p2 = self.tools['picard']['PATH']
			p3 = outbam
			p4 = re.sub("\.raw\.bam$", ".sort.bam", outbam)
			messagelist.append(commandformat.format(p0, p1, p2, p3, p4))
			messagelist.append(self._stat_command_formact("Step2 sortsam"))
			messagelist.append("rm %s\n" % p3)
			commandformat = "{0} {1} {2} {3}\n\n"
			p0 = self.tools['python']['PATH']
			p1 = self.tools['bam2gender']['PATH']
			p2 = p4
			p3 = os.path.join(self.qcpath, ".".join([self.sample, lanes, 'gender']))
			messagelist.append(commandformat.format(p0, p1, p2, p3))
			messagelist.append(self._stat_command_formact("Step2 gender check"))
			messagelist.append("gender=`awk '{print $2}' %s`\n" % p3)
			command = "\n\t".join(self._bwa_alignment(mode, 'female', fqlist, outbam))
			messagelist.append('if [ $gender == female ]; then\n\t %s \n\t' % command)
			ms = "Step1 bwa realign %s %s " % (mode, lanes)
			messagelist.append(self._stat_command_formact(ms, 2))
			commandformat = "\n\t{0} -Djava.io.tmpdir={1} -jar {2}/SortSam.jar INPUT={3} OUTPUT={4} " \
			                "SORT_ORDER=coordinate VALIDATION_STRINGENCY=SILENT\n\t"
			p0 = self.tools['JAVA']['PATH']
			p1 = self.javatmp
			p2 = self.tools['picard']['PATH']
			p3 = outbam
			p4 = re.sub("\.raw\.bam$", ".sort.bam", outbam)
			messagelist.append(commandformat.format(p0, p1, p2, p3, p4))
			messagelist.append(self._stat_command_formact("Step2 Resortsam", 2))
			messagelist.append("\trm %s\nfi\n" % p3)
			messagelist = self.bash_header_and_foot(messagelist, "Step2 align")
			f_out = os.path.join(self.scriptpath, ".".join(["Step2", self.sample, lanes, "align.sh"]))
			with open(f_out, 'w') as fout:
				fout.write("".join(messagelist))

	def step3_merge_bam(self):
		"""
		Step3 bam merge
		"""
		bamlist = [os.path.join(self.alignpath, ".".join([self.sample, lanes, '.sort.bam']))
		           for lanes in sorted(self._sample.fastq['fqlist'].keys())]
		if len(bamlist) == 1:
			command = 'cp %s %s\n' % (bamlist[0], self.finalbam)
		else:
			commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} {3} OUTPUT={4} VALIDATION_STRINGENCY=SILENT\n"
			p0 = self.tools['JAVA']['PATH']
			p1 = self.javatmp
			p2 = os.path.join(self.tools['picard']['PATH'], "MergeSamFiles.jar")
			p3 = " ".join(['INPUT=%s' % bam for bam in bamlist])
			p4 = self.finalbam
			command = commandformat.format(p0, p1, p2, p3, p4)
		messagelist = [command, self._stat_command_formact("Step3 merge bam"),
		               "rm -f %s %s\n\n" % (' '.join(bamlist), ' '.join([bam + '.bai' for bam in bamlist])),
		               "{0} index {1}\n\n".format(self.tools['samtools']['PATH'], self.finalbam),
		               self._stat_command_formact("Step3 index bam")]
		messagelist = self.bash_header_and_foot(messagelist, "Step3 bam merge")
		f_out = os.path.join(self.scriptpath, ".".join(["Step3", self.sample, "merge.sh"]))
		with open(f_out, 'w') as fout:
			fout.write("".join(messagelist))

	def step4_dupmark_bam(self):
		"""
		Step4 Mark duplicate
		"""
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} MAX_FILE_HANDLES_FOR_READ_ENDS_MAP=8000 INPUT={3} " \
		                "OUTPUT={4} METRICS_FILE={5} VALIDATION_STRINGENCY=SILENT\n\n"
		p0 = self.tools['JAVA']['PATH']
		p1 = self.javatmp
		p2 = os.path.join(self.tools['picard']['PATH'], "MarkDuplicates.jar")
		p3 = self.finalbam
		p4 = re.sub("\.final\.bam$", ".sort.dup.bam", p3)
		p5 = re.sub("\.final\.bam$", ".dup.metrics", p3)
		command = commandformat.format(p0, p1, p2, p3, p4, p5)
		messagelist = [command, self._stat_command_formact("Step4 MarkDuplicates")]
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} INPUT={3} OUTPUT={4} VALIDATION_STRINGENCY=SILENT\n\n"
		p2 = os.path.join(self.tools['picard']['PATH'], "FixMateInformation.jar")
		command = commandformat.format(p0, p1, p2, p4, p3)
		messagelist.append(command)
		messagelist.append(self._stat_command_formact("Step4 FixMateInformation"))
		messagelist.append("rm -f %s %s\n" % (p4, p5))
		messagelist.append("{0} index {1}\n\n".format(self.tools['samtools']['PATH'], self.finalbam))
		messagelist = self.bash_header_and_foot(messagelist, "Step4 bam MarkDuplicates")
		f_out = os.path.join(self.scriptpath, ".".join(["Step4", self.sample, "dupmark.sh"]))
		with open(f_out, 'w') as fout:
			fout.write("".join(messagelist))

	def step5_realigner(self):
		"""
		Step5 RealignerTargetCreator, IndelRealigner, BaseRecalibrator, PrintReads
		"""
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -I {4} -T RealignerTargetCreator {5} -L {6} -o {7}\n"
		p0 = self.tools['JAVA']['PATH']
		p1 = self.javatmp
		p2 = self.tools['GATK3']['PATH']
		p3 = self.tools['Reference']['male']
		p4 = self.finalbam
		p5 = self.tools['GATK3']['Parameters']['RealignerTargetCreator']
		p6 = self.flankbed
		p7 = re.sub('\.final\.bam$', '.realn_data.intervals', p4)
		command = commandformat.format(p0, p1, p2, p3, p4, p5, p6, p7)
		messagelist = [command, self._stat_command_formact("Step5 RealignerTargetCreator")]
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -I {4} -T IndelRealigner -filterNoBases" \
		                " -targetIntervals {5} -o {6}\n\n"
		p5 = p7
		p6 = re.sub('\.final\.bam$', 'sort.realn.bam', p4)
		command = commandformat.format(p0, p1, p2, p3, p4, p5, p6)
		messagelist.append(command)
		messagelist.append(self._stat_command_formact("Step5 IndelRealigner"))
		messagelist.append("rm %s\n" % p5)
		messagelist.append("mv %s %s\n" % (p6, p4))
		messagelist.append("mv %s %s\n" % (re.sub('bam$', 'bai', p6), p4 + '.bai'))
		cf = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -I {4} -T BaseRecalibrator {5} -L {6} -knownSites {7} -o {8}\n\n"
		p5 = self.tools['GATK3']['Parameters']['BaseRecalibrator']
		p6 = self.flankbed
		p7 = self.tools['dbsnp']['PATH']
		p8 = re.sub('\.final\.bam$', '.recal_data.grp', p4)
		command = cf.format(p0, p1, p2, p3, p4, p5, p6, p7, p8)
		messagelist.append(command)
		messagelist.append(self._stat_command_formact("Step5 BaseRecalibrator"))
		cf = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -I {4} -T PrintReads {5} -filterNoBases -BQSR {6} -o {7}\n\n"
		p5 = self.tools['GATK3']['Parameters']['PrintReads']
		p6 = p8
		p7 = re.sub('\.final\.bam$', '.recal_data.bam', p4)
		command = cf.format(p0, p1, p2, p3, p4, p5, p6, p7)
		messagelist.append(command)
		messagelist.append(self._stat_command_formact("Step5 PrintReads"))
		messagelist.append("rm %s\n" % p6)
		messagelist.append("mv %s %s\n" % (p7, p4))
		messagelist.append("mv %s %s\n" % (re.sub('bam$', 'bai', p7), p4 + '.bai'))
		messagelist = self.bash_header_and_foot(messagelist, "Step5 RealignerTargetCreator")
		f_out = os.path.join(self.scriptpath, ".".join(["Step5", self.sample, "RealignerTargetCreator.sh"]))
		with open(f_out, 'w') as fout:
			fout.write("".join(messagelist))

	def step6_1_variation_call(self):
		"""
		Step6 variation call, filter, phasing
		"""
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -I {4} -l INFO -T HaplotypeCaller -L {5} " \
		                "-rf BadCigar -o {6}  -A AlleleBalance -A HaplotypeScore {7}\n\n"
		p0 = self.tools['JAVA']['PATH']
		p1 = self.javatmp
		p2 = self.tools['GATK3']['PATH']
		p3 = self.tools['Reference']['male']
		p4 = self.finalbam
		p5 = self.flankbed
		p6 = os.path.join(self.vcfpath, self.sample + '.raw.vcf')
		p7 = self.tools['GATK3']['Parameters']['Variation call']
		command = commandformat.format(p0, p1, p2, p3, p4, p5, p6, p7)
		messagelist = [command, self._stat_command_formact("Step6.1 variation calling")]
		cf = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -T SelectVariants {4} --variant {5} -o {6} -selectType SNP \n\n"
		p4 = self.tools['GATK3']['Parameters']['Variation select']
		p5 = p6
		p6 = os.path.join(self.vcfpath, self.sample + '.raw.snv.vcf')
		command = cf.format(p0, p1, p2, p3, p4, p5, p6)
		messagelist.append(command)
		messagelist.append(self._stat_command_formact("Step6.1 snp select"))
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -T VariantFiltration --filterExpression \"{4}\" " \
		                "--variant {5} -o {6}  --filterName \"StandardFilter\" \n\n"
		p4 = self.tools['GATK3']['Parameters']['snv_filter']
		p5 = p6
		p6 = os.path.join(self.vcfpath, self.sample + '.filter.snv.vcf')
		messagelist.append(commandformat.format(p0, p1, p2, p3, p4, p5, p6))
		messagelist.append(self._stat_command_formact("Step6.1 snp filter"))
		messagelist.append("rm %s %s\n" % (p5, p5 + '.idx'))
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -T ReadBackedPhasing -I {4} --variant {5} -o {6}\n\n"
		p4 = self.finalbam
		p5 = p6
		p6 = os.path.join(self.vcfpath, self.sample + '.snv.vcf')
		messagelist.append(commandformat.format(p0, p1, p2, p3, p4, p5, p6))
		messagelist.append(self._stat_command_formact("Step6.1 snv phasing"))
		messagelist.append("rm %s %s\n" % (p5, p5 + '.idx'))
		cf = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -T SelectVariants {4} --variant {5} -o {6} -selectType INDEL \n"
		p4 = self.tools['GATK3']['Parameters']['Variation select']
		p5 = os.path.join(self.vcfpath, self.sample + '.raw.vcf')
		p6 = os.path.join(self.vcfpath, self.sample + '.raw.indel.vcf')
		messagelist.append(cf.format(p0, p1, p2, p3, p4, p5, p6))
		messagelist.append(self._stat_command_formact("Step6.1 indel select"))
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -T VariantFiltration --filterExpression \"{4}\" " \
		                "--variant {5} -o {6}  --filterName \"StandardFilter\" \n\n"
		p4 = self.tools['GATK3']['Parameters']['indel_filter']
		p5 = p6
		p6 = os.path.join(self.vcfpath, self.sample + '.indel.vcf')
		messagelist.append(commandformat.format(p0, p1, p2, p3, p4, p5, p6))
		messagelist.append(self._stat_command_formact("Step6.1 indel filter"))
		messagelist.append("rm %s %s\n" % (p5, p5 + '.idx'))
		commandformat = "{0} -Djava.io.tmpdir={1} -jar {2} -R {3} -T CombineVariants {4} --variant {5} " \
		                "--variant {6} -o {7} -genotypeMergeOptions UNSORTED\n"
		p4 = self.tools['GATK3']['Parameters']['combine_variation_select']
		p5 = os.path.join(self.vcfpath, self.sample + '.snv.vcf')
		p7 = os.path.join(self.vcfpath, self.sample + '.vcf')
		messagelist.append(commandformat.format(p0, p1, p2, p3, p4, p5, p6, p7))
		messagelist.append(self._stat_command_formact("Step6.1 CombineVariants filter"))
		commandformat = "{0} {1} {2} {3} {4}\n"
		p0 = self.tools['python']['PATH']
		p1 = self.tools['vcf_phasing']['PATH']
		p2 = self.finalbam
		p3 = p7
		p4 = self.finalvcf
		messagelist.append(commandformat.format(p0, p1, p2, p3, p4))
		messagelist.append(self._stat_command_formact("Step6.1 vcf phasing"))
		messagelist = self.bash_header_and_foot(messagelist, "Step6.1 vcf calling")
		f_out = os.path.join(self.scriptpath, ".".join(["Step6.1", self.sample, "vcf_calling.sh"]))
		with open(f_out, 'w') as fout:
			fout.write("".join(messagelist))

	def step6_2_depth_qc(self):
		"""
		Step6 QC
		"""
		commandformat = "{0} {1} -b {2} -o {3} -c {4} --plot\n\n"
		p0 = self.tools['python']['PATH']
		p1 = self.tools['depthqc']['PATH']
		p2 = self.finalbam
		p3 = self.qcpath
		p4 = self.configfile
		messagelist = self.bash_header_and_foot([commandformat.format(p0, p1, p2, p3, p4)], "Step6.2 depth QC")
		f_out = os.path.join(self.scriptpath, ".".join(["Step6.2", self.sample, "depthQC.sh"]))
		with open(f_out, 'w') as fout:
			fout.write("".join(messagelist))


def main():
	usage = 'Usage: %prog [-h] [--version] --samplelist [samplelist] --config [config.json] [options]'
	description = 'A Simple pipeline for the analysis of human data generated by NGS approaches.'
	author = 'Author: joeyhwong@hotmail.com'
	parser = OptionParser(usage=usage, version='%prog 1.1', description=description, epilog=author)
	expect = OptionGroup(parser, 'Expected arguments', 'Caution: These parameters are necessary for Rhea_Chip.')
	expect.add_option('-s', '--samplelist', metavar='FILE', dest='samplelist',
	                  help=r'''The sample list file
	                       Column 1:    sample name
	                       Column 2:    family name
	                       Column 3:    library
	                       Column 4:    FQ file [formact:
	                                                lane1/fq1:lane1/adapter1;lane1/fq2:lane1/adapter2|
	                                                lane2/fq1:lane2/adapter1;lane2/fq2:lane2/adapter2|...]
	                       Column 5:    case/control''')
	expect.add_option('-c', '--config', metavar='FILE', dest='config',
	                  help='The config file, contain all specific settings in a json file')
	parser.add_option_group(expect)
	optinal = OptionGroup(parser, 'Optional arguments', 'Caution: If you do not set these parameters in addition,'
	                                                    ' Rhea_Chip will select the default value.')
	optinal.add_option('-o', '--outdir', dest='outdir', default=os.getcwd(),
	                   help='The output dir [ default: %s ]' % os.getcwd())
	parser.add_option_group(optinal)
	options, args = parser.parse_args()
	if not options.samplelist or not options.config:
		parser.print_help()
		return 'Expected arguments lost !!!'
	samplelist = os.path.realpath(options.samplelist)
	config = os.path.realpath(options.config)
	outdir = os.path.realpath(options.outdir)
	prepair_dir = CreateFolder(outdir)
	prepair_dir.create_subdirectory(['alignment', 'doc', 'doc/QC', 'fq', 'fq/raw_data',
	                                 'fq/clean_data', 'javatmp', 'script', 'variation'])
	baseconfig = ConfigPhrase(config, os.path.join(outdir, 'doc', 'Rhea_chip.config'))
	if baseconfig.config_stat == 0:
		raise ValueError('Sorry, expected arguments in config lost !!!')
	sample = SampleMessage(samplelist)
	sample.work_path_prepare(outdir)
	for sample_name, sample_message in sample.samples.iteritems():
		try:
			pipeline = Pipeline(sample_message, baseconfig.tools, outdir)
			pipeline.run()
		except Exception:
			logger.info("Sorry, sample %s may have some problem !!" % sample_name)
			continue
	if os.path.isfile(os.path.join(outdir, 'doc', 'Rhea_chip.log')):
		os.remove(os.path.join(outdir, 'doc', 'Rhea_chip.log'))
	shutil.copy(os.path.join(temppath, 'Rhea_chip.log'), os.path.join(outdir, 'doc', 'Rhea_chip.log'))
	if os.path.isfile(os.path.join(outdir, 'doc', 'sample.list')):
		if os.path.isfile(os.path.join(outdir, 'doc', 'sample.list' + temptime)):
			os.remove(os.path.join(outdir, 'doc', 'sample.list' + temptime))
		shutil.copy(os.path.join(temppath, "sample.list"), os.path.join(outdir, 'doc', 'sample.list.' + temptime))
	else:
		shutil.copy(os.path.join(temppath, "sample.list"), os.path.join(outdir, 'doc', 'sample.list'))
	for i in ("Target", "Flank"):
		bedfile = baseconfig.tools["Bed"]["%s bed" % i]
		normbed = os.path.join(outdir, 'doc', ".".join([temptime, i, 'phig.norm.bed']))
		if os.path.isfile(normbed):
			os.remove(normbed)
		elif os.path.isdir(normbed):
			shutil.rmtree(normbed)
		shutil.copy(bedfile, normbed)
	return "All scripts are ready !"


if __name__ == '__main__':
	sys.exit(main())
